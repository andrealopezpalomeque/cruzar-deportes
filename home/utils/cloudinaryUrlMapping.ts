// Import the URL mapping generated by migration
import urlMapping from '../scripts/url-mapping.json' with { type: 'json' }

// Type the mapping
const cloudinaryUrlMapping: Record<string, string> = urlMapping

// Pre-compute team level lookups to avoid scanning the full mapping repeatedly
const teamUrlCache: Record<string, string[]> = {}

for (const [localPath, cloudinaryUrl] of Object.entries(cloudinaryUrlMapping)) {
  const match = localPath.match(/^\/images\/([^/]+)\/([^/]+)\//)
  if (!match) continue

  const [, category, teamKey] = match
  const cacheKey = `${category}/${teamKey}`

  if (!teamUrlCache[cacheKey]) {
    teamUrlCache[cacheKey] = []
  }

  teamUrlCache[cacheKey].push(cloudinaryUrl)
}

for (const cacheKey of Object.keys(teamUrlCache)) {
  teamUrlCache[cacheKey].sort()
}

/**
 * Get Cloudinary URL for a local image path
 */
export function getCloudinaryUrl(localPath: string): string | null {
  // Normalize the local path to match the mapping format
  const normalizedPath = localPath.startsWith('/') ? localPath : `/${localPath}`

  return cloudinaryUrlMapping[normalizedPath] || null
}

/**
 * Get all Cloudinary URLs for a team
 */
export function getTeamCloudinaryUrls(teamKey: string, category: string): string[] {
  const cacheKey = `${category}/${teamKey}`

  if (teamUrlCache[cacheKey]) {
    return teamUrlCache[cacheKey]
  }

  // Support team keys that may still use hyphen delimiters
  const normalizedKey = teamKey.replace(/-/g, '_')
  const fallbackKey = `${category}/${normalizedKey}`

  if (teamUrlCache[fallbackKey]) {
    teamUrlCache[cacheKey] = teamUrlCache[fallbackKey]
    return teamUrlCache[fallbackKey]
  }

  return []
}

/**
 * Check if we have Cloudinary URLs available
 */
export function hasCloudinaryUrls(): boolean {
  return Object.keys(cloudinaryUrlMapping).length > 0
}

/**
 * Get total number of migrated images
 */
export function getMigratedImageCount(): number {
  return Object.keys(cloudinaryUrlMapping).length
}
